// SPDX-FileCopyrightText: Copyright 2025 Carabiner Systems, Inc
// SPDX-License-Identifier: Apache-2.0

package v1

import (
	"fmt"
	"slices"

	"github.com/openvex/go-vex/pkg/vex"
	gopurl "github.com/package-url/packageurl-go"
)

type Package struct {
	Type    string `json:"type"`
	Name    string `json:"name"`
	Version string `json:"version"`
	Purl    string `json:"purl"`
}

func (p *Package) SetPurl(purl string) error {
	parsed, err := gopurl.FromString(purl)
	if err != nil {
		return fmt.Errorf("parsing package url: %w", err)
	}
	p.Purl = purl
	p.Name = parsed.Name
	p.Version = parsed.Version
	return nil
}

type Vulnerability struct {
	ID        string   `json:"id"`
	Aliases   []string `json:"aliases"`
	Summary   string   `json:"-"`
	Details   string   `json:"-"`
	Component *Package `json:"component"`
}

func (vuln *Vulnerability) HasId(id string) bool {
	if vuln.ID == id {
		return true
	}
	return slices.Contains(vuln.Aliases, id)
}

func (vuln *Vulnerability) ComponentPurl() string {
	if vuln.Component == nil {
		return ""
	}
	return vuln.Component.Purl
}

func (vuln *Vulnerability) ToVex() *vex.Vulnerability {
	aliases := []vex.VulnerabilityID{}
	for _, a := range vuln.Aliases {
		aliases = append(aliases, vex.VulnerabilityID(a))
	}
	return &vex.Vulnerability{
		ID:          vuln.ID,
		Name:        vex.VulnerabilityID(vuln.ID),
		Description: vuln.Summary,
		Aliases:     aliases,
	}
}

func (vuln *Vulnerability) VexComponent() *vex.Component {
	if vuln.Component == nil || vuln.Component.Purl == "" {
		return nil
	}
	return &vex.Component{
		ID: vuln.ComponentPurl(),
		Identifiers: map[vex.IdentifierType]string{
			vex.PURL: vuln.ComponentPurl(),
		},
	}
}

type Scanner interface {
	GetBranchVulnerabilities(*Branch) ([]*Vulnerability, error)
}
